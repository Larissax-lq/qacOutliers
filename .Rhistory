data_with_lof <- data.frame(ID = 1:nrow(data), data, LOF_Score = lof_scores)
subset <- data_with_lof[data_with_lof$LOF_Score > 1, ]
#list for print function
results <- list(
Method = "LoF",
Variables = colnames(data),
Row = index,
Score = subset[LOF_Score,],
alpha = alpha
)
#setting up class
class(results) <- "multiOutliers"
}
if(method=="mahalanobis"){
library(dplyr)
library(Routliers)
#taking only numeric data
numeric_data <-select_if(data, is.numeric)
#make this into a matrix
mat <- as.matrix(numeric_data)
#run matrix on function and store results
results <- outliers_mahalanobis(x=mat, alpha=alpha)
index <- results$outliers_pos
score <- results$dist_from_center
subset <- data[index,]
#list for print function
results <- list(
Method = "mahalanobis",
Variables = colnames(numeric_data),
Row = index,
Score = subset[score,],
alpha = alpha
)
#setting up class
class(results) <- "multiOutliers"
return(results)
}
if (method == "kNN") {
if (length(index)!=0) {
data <- as.matrix(data)
}
# Calculate pairwise distances
dist_matrix <- as.matrix(dist(data))
# Get k-nearest neighbors for each point (excluding self-distance of 0)
knn_scores <- apply(dist_matrix, 1, function(row) {
sort(row, partial = k + 1)[2:(k + 1)]
})
# Calculate the average distance to the k-nearest neighbors
avg_knn_distances <- rowMeans(knn_scores)
# Determine the outliers based on the threshold
cutoff <- quantile(avg_knn_distances, threshold)
outlier_indices <- which(avg_knn_distances > cutoff)
# Prepare results in the specified format
results <- list(
Method = "kNN",
Variables = colnames(data),  # Get variable names from the data matrix
Row = outlier_indices,       # Row number of each outlier in the original dataframe
Score = avg_knn_distances[outlier_indices],  # Score of each outlier
k = k                         # The value of k
)
class(results) <- "multiOutliers"
return(results)
}
if(method=="iForest"){
library(dplyr)
library(outForest)
if (!is.matrix(data) && !is.data.frame(data)) {
stop("Data should be a matrix or data frame.")
}
#data needs to be numeric
numeric_data <-select_if(data, is.numeric)
ch <- outForest(numeric_data, replace = "no" )
#actual outliers
results <- outliers(ch)
class(results) <- "multiOutliers"
return(results)
}
multiOutliers <- function(data, varlist=names(data), method, minPts=5, k=5, threshold =0.95, alpha=0.1,na.rm=TRUE, ...){
#removing missing data
if(na.rm) data <- na.omit(data[,varlist])
#add other methods as people finish them here
method <- match.arg(method, c("kNN", "LoF", "mahalanobis", "iForest"))
if(method=="LoF"){
# Check if data is a matrix or data frame and convert if necessary
if (!is.matrix(data) && !is.data.frame(data)) {
stop("Data should be a matrix or data frame.")
}
# Remove any non numeric data
data <- data[sapply(data, is.numeric)]
# Check if there are enough points for the LOF calculation
if (nrow(data) <= minPts) {
stop("Number of data points must be greater than minPts.")
}
# Calculate the LoF scores
lof_scores <- dbscan::lof(data, minPts = minPts)
# Append the LOF scores as a new column in the data frame
data_with_lof <- data.frame(ID = 1:nrow(data), data, LOF_Score = lof_scores)
subset <- data_with_lof[data_with_lof$LOF_Score > 1, ]
#list for print function
results <- list(
Method = "LoF",
Variables = colnames(data),
Row = index,
Score = subset[LOF_Score,],
alpha = alpha
)
#setting up class
class(results) <- "multiOutliers"
}
if(method=="mahalanobis"){
library(dplyr)
library(Routliers)
#taking only numeric data
numeric_data <-select_if(data, is.numeric)
#make this into a matrix
mat <- as.matrix(numeric_data)
#run matrix on function and store results
results <- outliers_mahalanobis(x=mat, alpha=alpha)
index <- results$outliers_pos
score <- results$dist_from_center
subset <- data[index,]
#list for print function
results <- list(
Method = "mahalanobis",
Variables = colnames(numeric_data),
Row = index,
Score = subset[score,],
alpha = alpha
)
#setting up class
class(results) <- "multiOutliers"
return(results)
}
if (method == "kNN") {
if (length(index)!=0) {
data <- as.matrix(data)
}
# Calculate pairwise distances
dist_matrix <- as.matrix(dist(data))
# Get k-nearest neighbors for each point (excluding self-distance of 0)
knn_scores <- apply(dist_matrix, 1, function(row) {
sort(row, partial = k + 1)[2:(k + 1)]
})
# Calculate the average distance to the k-nearest neighbors
avg_knn_distances <- rowMeans(knn_scores)
# Determine the outliers based on the threshold
cutoff <- quantile(avg_knn_distances, threshold)
outlier_indices <- which(avg_knn_distances > cutoff)
# Prepare results in the specified format
results <- list(
Method = "kNN",
Variables = colnames(data),  # Get variable names from the data matrix
Row = outlier_indices,       # Row number of each outlier in the original dataframe
Score = avg_knn_distances[outlier_indices],  # Score of each outlier
k = k                         # The value of k
)
class(results) <- "multiOutliers"
return(results)
}
if(method=="iForest"){
library(dplyr)
library(outForest)
if (!is.matrix(data) && !is.data.frame(data)) {
stop("Data should be a matrix or data frame.")
}
#data needs to be numeric
numeric_data <-select_if(data, is.numeric)
ch <- outForest(numeric_data, replace = "no" )
#actual outliers
results <- outliers(ch)
class(results) <- "multiOutliers"
return(results)
}
multiOutliers(mtcars, method="mahalanobis")
multiOutliers <- function(data, varlist=names(data), method, minPts=5, k=5, threshold =0.95, alpha=0.1,na.rm=TRUE, ...){
#removing missing data
if(na.rm) data <- na.omit(data[,varlist])
#add other methods as people finish them here
method <- match.arg(method, c("kNN", "LoF", "mahalanobis", "iForest"))
if(method=="LoF"){
# Check if data is a matrix or data frame and convert if necessary
if (!is.matrix(data) && !is.data.frame(data)) {
stop("Data should be a matrix or data frame.")
}
# Remove any non numeric data
data <- data[sapply(data, is.numeric)]
# Check if there are enough points for the LOF calculation
if (nrow(data) <= minPts) {
stop("Number of data points must be greater than minPts.")
}
# Calculate the LoF scores
lof_scores <- dbscan::lof(data, minPts = minPts)
# Append the LOF scores as a new column in the data frame
data_with_lof <- data.frame(ID = 1:nrow(data), data, LOF_Score = lof_scores)
subset <- data_with_lof[data_with_lof$LOF_Score > 1, ]
#list for print function
results <- list(
Method = "LoF",
Variables = colnames(data),
Row = index,
Score = subset[LOF_Score,],
alpha = alpha
)
#setting up class
class(results) <- "multiOutliers"
}
if(method=="mahalanobis"){
library(dplyr)
library(Routliers)
#taking only numeric data
numeric_data <-select_if(data, is.numeric)
#make this into a matrix
mat <- as.matrix(numeric_data)
#run matrix on function and store results
results <- outliers_mahalanobis(x=mat, alpha=alpha)
index <- results$outliers_pos
score <- results$dist_from_center
subset <- data[index,]
#list for print function
results <- list(
Method = "mahalanobis",
Variables = colnames(numeric_data),
Row = index,
Score = subset[score,],
alpha = alpha
)
#setting up class
class(results) <- "multiOutliers"
return(results)
}
if (method == "kNN") {
if (length(index)!=0) {
data <- as.matrix(data)
}
# Calculate pairwise distances
dist_matrix <- as.matrix(dist(data))
# Get k-nearest neighbors for each point (excluding self-distance of 0)
knn_scores <- apply(dist_matrix, 1, function(row) {
sort(row, partial = k + 1)[2:(k + 1)]
})
# Calculate the average distance to the k-nearest neighbors
avg_knn_distances <- rowMeans(knn_scores)
# Determine the outliers based on the threshold
cutoff <- quantile(avg_knn_distances, threshold)
outlier_indices <- which(avg_knn_distances > cutoff)
# Prepare results in the specified format
results <- list(
Method = "kNN",
Variables = colnames(data),  # Get variable names from the data matrix
Row = outlier_indices,       # Row number of each outlier in the original dataframe
Score = avg_knn_distances[outlier_indices],  # Score of each outlier
k = k                         # The value of k
)
class(results) <- "multiOutliers"
return(results)
}
if(method=="iForest"){
library(dplyr)
library(outForest)
if (!is.matrix(data) && !is.data.frame(data)) {
stop("Data should be a matrix or data frame.")
}
#data needs to be numeric
numeric_data <-select_if(data, is.numeric)
ch <- outForest(numeric_data, replace = "no" )
#actual outliers
results <- outliers(ch)
class(results) <- "multiOutliers"
return(results)
}
print.multiOutliers <- function(x, ...) {
if(!inherits(x, "multiOutliers")){
stop("This functon requires an object created by multiOutliers")
}
require(cli)
cat("Method:", x$Method)
cat("\nVariables:", x$Variables)
cat("\nRow:", x$Row)
cat("\nScore:", x$Score)
if (length(x) >= 5) {
cat("\nOption 1:", names(x)[5], "-", x[[5]])
}
if (length(x) >= 6) {
cat("\nOption 2:", names(x)[6], "-", x[[6]])
}
return(x)
}
multiOutliers(mtcars, method="mahalanobis")
multiOutliers <- function(data, varlist=names(data), method, minPts=5, k=5, threshold =0.95, alpha=0.1,na.rm=TRUE, ...){
#removing missing data
if(na.rm) data <- na.omit(data[,varlist])
#add other methods as people finish them here
method <- match.arg(method, c("kNN", "LoF", "mahalanobis", "iForest"))
if(method=="LoF"){
# Check if data is a matrix or data frame and convert if necessary
if (!is.matrix(data) && !is.data.frame(data)) {
stop("Data should be a matrix or data frame.")
}
# Remove any non numeric data
data <- data[sapply(data, is.numeric)]
# Check if there are enough points for the LOF calculation
if (nrow(data) <= minPts) {
stop("Number of data points must be greater than minPts.")
}
# Calculate the LoF scores
lof_scores <- dbscan::lof(data, minPts = minPts)
# Append the LOF scores as a new column in the data frame
data_with_lof <- data.frame(ID = 1:nrow(data), data, LOF_Score = lof_scores)
subset <- data_with_lof[data_with_lof$LOF_Score > 1, ]
#list for print function
results <- list(
Method = "LoF",
Variables = colnames(data),
Row = index,
Score = subset[LOF_Score,],
alpha = alpha
)
#setting up class
class(results) <- "multiOutliers"
}
if(method=="mahalanobis"){
library(dplyr)
library(Routliers)
#taking only numeric data
numeric_data <-select_if(data, is.numeric)
#make this into a matrix
mat <- as.matrix(numeric_data)
#run matrix on function and store results
results <- outliers_mahalanobis(x=mat, alpha=alpha)
index <- results$outliers_pos
score <- results$dist_from_center
subset <- data[index,]
#list for print function
results <- list(
Method = "mahalanobis",
Variables = colnames(numeric_data),
Row = index,
Score = subset[score,],
alpha = alpha
)
#setting up class
class(results) <- "multiOutliers"
return(results)
}
if (method == "kNN") {
if (length(index)!=0) {
data <- as.matrix(data)
}
# Calculate pairwise distances
dist_matrix <- as.matrix(dist(data))
# Get k-nearest neighbors for each point (excluding self-distance of 0)
knn_scores <- apply(dist_matrix, 1, function(row) {
sort(row, partial = k + 1)[2:(k + 1)]
})
# Calculate the average distance to the k-nearest neighbors
avg_knn_distances <- rowMeans(knn_scores)
# Determine the outliers based on the threshold
cutoff <- quantile(avg_knn_distances, threshold)
outlier_indices <- which(avg_knn_distances > cutoff)
# Prepare results in the specified format
results <- list(
Method = "kNN",
Variables = colnames(data),  # Get variable names from the data matrix
Row = outlier_indices,       # Row number of each outlier in the original dataframe
Score = avg_knn_distances[outlier_indices],  # Score of each outlier
k = k                         # The value of k
)
class(results) <- "multiOutliers"
return(results)
}
if(method=="iForest"){
library(dplyr)
library(outForest)
if (!is.matrix(data) && !is.data.frame(data)) {
stop("Data should be a matrix or data frame.")
}
#data needs to be numeric
numeric_data <-select_if(data, is.numeric)
ch <- outForest(numeric_data, replace = "no" )
#actual outliers
outliers_list <- outliers(ch)
# Prepare results in the specified format
results <- list(
Method = "iForest",
Variables = outliers_list$col,  # Get variable names from the data matrix
Row = outliers_list$row,       # Row number of each outlier in the original dataframe
Score = outliers_list$score,  # Score of each outlier
threshold = outliers_list$threshold                      # The value of k
)
class(results) <- "multiOutliers"
return(results)
}
print.multiOutliers <- function(x, ...) {
if(!inherits(x, "multiOutliers")){
stop("This functon requires an object created by multiOutliers")
}
cat("Method:", x$Method)
cat("\nVariables:", x$Variables)
cat("\nRow:", x$Row)
cat("\nScore:", x$Score)
if (length(x) >= 5) {
cat("\nOption 1:", names(x)[5], "-", x[[5]])
}
if (length(x) >= 6) {
cat("\nOption 2:", names(x)[6], "-", x[[6]])
}
return(x)
}
multiOutliers(mtcars, method="mahalanobis")
multiOutliers <- function(data, varlist=names(data), method, minPts=5, k=5, threshold =0.95 ,alpha=0.1, na.rm=TRUE, ...){
#Get the dataset name
dataset_name <- deparse(substitute(data))
#removing missing data
if(na.rm) data <- na.omit(data[,varlist])
#add other methods as people finish them here
method <- match.arg(method, c("kNN", "LoF", "mahalanobis", "iForest"))
if(method=="LoF"){
# Check if data is a matrix or data frame and convert if necessary
if (!is.matrix(data) && !is.data.frame(data)) {
stop("Data should be a matrix or data frame.")
}
# Remove any non numeric data
data <- data[sapply(data, is.numeric)]
# Check if there are enough points for the LOF calculation
if (nrow(data) <= minPts) {
stop("Number of data points must be greater than minPts.")
}
# Calculate the LoF scores
lof_scores <- dbscan::lof(data, minPts = minPts)
# Append the LOF scores as a new column in the data frame
data_with_lof <- data.frame(ID = 1:nrow(data), data, LOF_Score = lof_scores)
subset <- data_with_lof[data_with_lof$LOF_Score > 1, ]
#setting up information and list for print function
results <- list(
method = "LoF", variables = colnames(subset), outliers = rownames(subset),
minPts = minPts, opt2 = NULL
)
class(results) <- "multiOutliers"
}
if(method=="mahalanobis"){
library(dplyr)
library(Routliers)
#taking only numeric data
numeric_data <-select_if(data, is.numeric)
#make this into a matrix
mat <- as.matrix(numeric_data)
#run matrix on function and store results
results <- outliers_mahalanobis(x=mat, alpha=alpha)
index <- results$outliers_pos
score <- results$
subset <- data[index,]
#list for print function
results <- list(
method = "LoF", variables = colnames(subset), outliers = rownames(subset),
minPts = minPts, opt2 = NULL
)
#setting up class
class(results) <- "multiOutliers"
}
if (method == "kNN") {
if (length(index)!=0) {
data <- as.matrix(data)
}
# Calculate pairwise distances
dist_matrix <- as.matrix(dist(data))
# Get k-nearest neighbors for each point (excluding self-distance of 0)
knn_scores <- apply(dist_matrix, 1, function(row) {
sort(row, partial = k + 1)[2:(k + 1)]
})
# Calculate the average distance to the k-nearest neighbors
avg_knn_distances <- rowMeans(knn_scores)
# Determine the outliers based on the threshold
cutoff <- quantile(avg_knn_distances, threshold)
outlier_indices <- which(avg_knn_distances > cutoff)
# Prepare results in the specified format
results <- list(
Method = "kNN",
Data = dataset_name,
Variables = colnames(data),
Row = outlier_indices,
Score = avg_knn_distances[outlier_indices],
k = k
)
class(results) <- "multiOutliers"
return(results)
}
if(method=="iForest"){
library(dplyr)
library(outForest)
if (!is.matrix(data) && !is.data.frame(data)) {
stop("Data should be a matrix or data frame.")
}
#data needs to be numeric
numeric_data <-select_if(data, is.numeric)
ch <- outForest(numeric_data, replace = "no" )
#actual outliers
results <- outliers(ch)
class(results) <- "multiOutliers"
return(results)
}
usethis::use_package("outliers")
pkgdown::build_site()
.Last.error
pkgdown:::build_site()
pkgdown::build_site_github_pages()
pkgdown::preview_site(path='sitemap.xml')
pkgdown:::build_site()
pkgdown::build_site_github_pages()
usethis::use_pkgdown()
usethis::use_pkgdown_github_pages()
pkgdown::build_site_github_pages()
pkgdown:::build_site()
