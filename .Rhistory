}
}
# Create the ggplot boxplot (optional, only for visualization)
library(ggplot2)
p <- ggplot(data, aes_string(y = column)) +
geom_boxplot(outlier.colour = "red", coef = 1.58) +
ggtitle(paste("Univariate Boxplot of", column)) +
theme_minimal()
print(p)
}
if(method=="mad"){
library(Routliers)
# Check if the input data is numeric
if (!is.numeric(data)) {
stop("Input data must be numeric.")
}
# Use the outliers_mad function to find outliers
res1 <- outliers_mad(data)
# Display the outliers
if (length(res1) == 0) {
cat("No outliers detected in the data.\n")
} else {
cat("Outliers detected:\n")
print(res1)
}
}
}
univOutliers <- function(data, x = NULL, method = "boxplot") {
# Ensure the method is either "boxplot" or "mad"
if (!(method %in% c("boxplot", "mad"))) {
stop("Method must be either 'boxplot' or 'mad'.")
}
# Identify numeric columns in the dataset
numeric_columns <- sapply(data, is.numeric)
# If 'x' is not specified, use all numeric columns
if (is.null(x)) {
x <- names(data)[numeric_columns]
} else {
if (!x %in% names(data)) stop(paste("The specified column", x, "does not exist in the data frame."))
x <- list(x)  # Convert to a list for uniform processing
}
# Loop through each numeric variable specified in 'x'
for (column in x) {
# Boxplot Method
if (method == "boxplot") {
# Calculate boxplot stats using base R
stats <- boxplot.stats(data[[column]])
# Check if outliers exist
if (length(stats$out) == 0) {
cat("No univariate outliers detected for", column, "\n")
} else {
cat("Outliers detected for", column, ":\n")
# Print outliers with their corresponding row numbers
outlier_rows <- which(data[[column]] %in% stats$out)
for (i in outlier_rows) {
cat("Row", i, ":", data[[column]][i], "\n")
}
}
# Create the ggplot boxplot (optional, only for visualization)
library(ggplot2)
p <- ggplot(data, aes_string(y = column)) +
geom_boxplot(outlier.colour = "red", coef = 1.58) +
ggtitle(paste("Univariate Boxplot of", column)) +
theme_minimal()
print(p)
}
if(method=="mad"){
library(Routliers)
# Check if the input data is numeric
if (!is.numeric(data)) {
stop("Input data must be numeric.")
}
# Use the outliers_mad function to find outliers
res1 <- outliers_mad(data)
# Display the outliers
if (length(res1) == 0) {
cat("No outliers detected in the data.\n")
} else {
cat("Outliers detected:\n")
print(res1)
}
}
}}
univOutliers(mtcars, "hp", method="boxplot")
univOutliers(mtcars, "mpg", method="boxplot")
univOutliers <- function(data, x = NULL, method = "boxplot") {
# Identify numeric columns in the dataset
numeric_columns <- sapply(data, is.numeric)
# If 'x' is not specified, use all numeric columns
if (is.null(x)) {
x <- names(data)[numeric_columns]
} else {
if (!x %in% names(data)) stop(paste("The specified column", x, "does not exist in the data frame."))
x <- list(x)  # Convert to a list for uniform processing
}
# Loop through each numeric variable specified in 'x'
for (column in x) {
# Boxplot Method
if (method == "boxplot") {
# Calculate boxplot stats using base R
stats <- boxplot.stats(data[[column]])
# Check if outliers exist
if (length(stats$out) == 0) {
cat("No univariate outliers detected for", column, "\n")
} else {
cat("Outliers detected for", column, ":\n")
# Print outliers with their corresponding row numbers
outlier_rows <- which(data[[column]] %in% stats$out)
for (i in outlier_rows) {
cat("Row", i, ":", data[[column]][i], "\n")
}
}
# Create the ggplot boxplot (optional, only for visualization)
library(ggplot2)
p <- ggplot(data, aes_string(y = column)) +
geom_boxplot(outlier.colour = "red", coef = 1.58) +
ggtitle(paste("Univariate Boxplot of", column)) +
theme_minimal()
print(p)
}
if(method=="mad"){
library(Routliers)
# Check if the input data is numeric
if (!is.numeric(data)) {
stop("Input data must be numeric.")
}
# Use the outliers_mad function to find outliers
res1 <- outliers_mad(data)
# Display the outliers
if (length(res1) == 0) {
cat("No outliers detected in the data.\n")
} else {
cat("Outliers detected:\n")
print(res1)
}
}
}}
univOutliers(mtcars, "mpg", method="boxplot")
univOutliers(mtcars, "hp", method="boxplot")
univOutliers(mtcars, method="boxplot")
=======
setwd("/Users/braedenfalzarano/Documents/class/qac356_advanced_R/ClassProject")
usethis::create_package("qacTeam")
# Return results
return(list(outliers = outliers, scores = avg_knn_distances))
# Return results
return(list(outliers = outliers, scores = avg_knn_distances))
if (length(avg_knn_distances) == 0) {
stop("Error: avg_knn_distances is empty.")
}
else{
if (method == "kNN") {
if (!is.matrix(data)) {
data <- as.matrix(data)
}
threshold <- 0.95
k <- 5
# Calculate pairwise distances
dist_matrix <- as.matrix(dist(data))
# Get k-nearest neighbors for each point (excluding self-distance of 0)
knn_scores <- apply(dist_matrix, 1, function(row) {
sort(row, partial = k + 1)[2:(k + 1)]
})
# Calculate the average distance to the k-nearest neighbors
avg_knn_distances <- rowMeans(knn_scores)
if (length(avg_knn_distances) == 0) {
stop("Error: avg_knn_distances is empty.")
}
# Determine the outliers based on the threshold
cutoff <- quantile(avg_knn_distances, threshold)
outliers <- which(avg_knn_distances > cutoff)
# Return results
return(list(outliers = outliers, scores = avg_knn_distances))
}
else {
multiOutliers <- function(data, x, y, method="mahalanobis", ...){
#add other methods as people finish them here
if(method=="LoF"){
# Check if data is a matrix or data frame and convert if necessary
if (!is.matrix(data) && !is.data.frame(data)) {
stop("Data should be a matrix or data frame.")
}
# Rmove any non numeric data
data <- data[sapply(data, is.numeric)]
# Check if there are enough points for the LOF calculation
if (nrow(data) <= minPts) {
stop("Number of data points must be greater than minPts.")
}
# Calculate the LoF scores
lof_scores <- dbscan::lof(data, minPts = minPts)
# Append the LOF scores as a new column in the data frame
data_with_lof <- data.frame(ID = 1:nrow(data), data, LOF_Score = lof_scores)
# Return the data frame with IDs, original data, and LOF scores
return(data_with_lof)
}
if(method=="mahalanobis"){
#create error messaging here for non-numeric variables
#select just the rows given by the user
subset <- select(data, {{x}}, {{y}})
#make this into a matrix
mat <- as.matrix(subset)
#run matrix on function and store results
results <- outliers_mahalanobis(x=mat)
print(results)
}
if (method == "kNN") {
if (!is.matrix(data)) {
data <- as.matrix(data)
}
threshold <- 0.95
k <- 5
# Calculate pairwise distances
dist_matrix <- as.matrix(dist(data))
# Get k-nearest neighbors for each point (excluding self-distance of 0)
knn_scores <- apply(dist_matrix, 1, function(row) {
sort(row, partial = k + 1)[2:(k + 1)]
})
# Calculate the average distance to the k-nearest neighbors
avg_knn_distances <- rowMeans(knn_scores)
if (length(avg_knn_distances) == 0) {
stop("Error: avg_knn_distances is empty.")
}
# Determine the outliers based on the threshold
cutoff <- quantile(avg_knn_distances, threshold)
outliers <- which(avg_knn_distances > cutoff)
# Return results
return(list(outliers = outliers, scores = avg_knn_distances))
}
else {
stop("Method supplied must be kNN, mahalanobis, iForest, or LoF.")
}
}
multiOutliers <- function(data, x, y, method="mahalanobis", ...){
#add other methods as people finish them here
if(method=="LoF"){
# Check if data is a matrix or data frame and convert if necessary
if (!is.matrix(data) && !is.data.frame(data)) {
stop("Data should be a matrix or data frame.")
}
# Rmove any non numeric data
data <- data[sapply(data, is.numeric)]
# Check if there are enough points for the LOF calculation
if (nrow(data) <= minPts) {
stop("Number of data points must be greater than minPts.")
}
# Calculate the LoF scores
lof_scores <- dbscan::lof(data, minPts = minPts)
# Append the LOF scores as a new column in the data frame
data_with_lof <- data.frame(ID = 1:nrow(data), data, LOF_Score = lof_scores)
# Return the data frame with IDs, original data, and LOF scores
return(data_with_lof)
}
if(method=="mahalanobis"){
#create error messaging here for non-numeric variables
#select just the rows given by the user
subset <- select(data, {{x}}, {{y}})
#make this into a matrix
mat <- as.matrix(subset)
#run matrix on function and store results
results <- outliers_mahalanobis(x=mat)
print(results)
}
if (method == "kNN") {
if (!is.matrix(data)) {
data <- as.matrix(data)
}
threshold <- 0.95
k <- 5
# Calculate pairwise distances
dist_matrix <- as.matrix(dist(data))
# Get k-nearest neighbors for each point (excluding self-distance of 0)
knn_scores <- apply(dist_matrix, 1, function(row) {
sort(row, partial = k + 1)[2:(k + 1)]
})
# Calculate the average distance to the k-nearest neighbors
avg_knn_distances <- rowMeans(knn_scores)
if (length(avg_knn_distances) == 0) {
stop("Error: avg_knn_distances is empty.")
}
# Determine the outliers based on the threshold
cutoff <- quantile(avg_knn_distances, threshold)
outliers <- which(avg_knn_distances > cutoff)
# Return results
return(list(outliers = outliers, scores = avg_knn_distances))
}
else {
stop("Method supplied must be kNN, mahalanobis, iForest, or LoF.")
}
}
multiOutliers <- function(data, x, y, method="mahalanobis", ...){
#add other methods as people finish them here
if(method=="LoF"){
# Check if data is a matrix or data frame and convert if necessary
if (!is.matrix(data) && !is.data.frame(data)) {
stop("Data should be a matrix or data frame.")
}
# Rmove any non numeric data
data <- data[sapply(data, is.numeric)]
# Check if there are enough points for the LOF calculation
if (nrow(data) <= minPts) {
stop("Number of data points must be greater than minPts.")
}
# Calculate the LoF scores
lof_scores <- dbscan::lof(data, minPts = minPts)
# Append the LOF scores as a new column in the data frame
data_with_lof <- data.frame(ID = 1:nrow(data), data, LOF_Score = lof_scores)
# Return the data frame with IDs, original data, and LOF scores
return(data_with_lof)
}
if(method=="mahalanobis"){
#create error messaging here for non-numeric variables
#select just the rows given by the user
subset <- select(data, {{x}}, {{y}})
#make this into a matrix
mat <- as.matrix(subset)
#run matrix on function and store results
results <- outliers_mahalanobis(x=mat)
print(results)
}
if (method == "kNN") {
if (!is.matrix(data)) {
data <- as.matrix(data)
}
threshold <- 0.95
k <- 5
# Calculate pairwise distances
dist_matrix <- as.matrix(dist(data))
# Get k-nearest neighbors for each point (excluding self-distance of 0)
knn_scores <- apply(dist_matrix, 1, function(row) {
sort(row, partial = k + 1)[2:(k + 1)]
})
# Calculate the average distance to the k-nearest neighbors
avg_knn_distances <- rowMeans(knn_scores)
# Determine the outliers based on the threshold
cutoff <- quantile(avg_knn_distances, threshold)
outliers <- which(avg_knn_distances > cutoff)
# Return results
return(list(outliers = outliers, scores = avg_knn_distances))
}
else {
stop("Method supplied must be kNN, mahalanobis, iForest, or LoF.")
}
}
multiOutliers(mtcars, method = "kNN")
multiOutliers(mtcars, method = "mahalanobis")
multiOutliers(mtcars, method = "mahalanobis")
multiOutliers(mtcars, method = "kNN")
multiOutliers <- function(data, x, y, method="mahalanobis", k = 0.5, threshold = 0.95,...){
#add other methods as people finish them here
if(method=="LoF"){
# Check if data is a matrix or data frame and convert if necessary
if (!is.matrix(data) && !is.data.frame(data)) {
stop("Data should be a matrix or data frame.")
}
# Rmove any non numeric data
data <- data[sapply(data, is.numeric)]
# Check if there are enough points for the LOF calculation
if (nrow(data) <= minPts) {
stop("Number of data points must be greater than minPts.")
}
# Calculate the LoF scores
lof_scores <- dbscan::lof(data, minPts = minPts)
# Append the LOF scores as a new column in the data frame
data_with_lof <- data.frame(ID = 1:nrow(data), data, LOF_Score = lof_scores)
# Return the data frame with IDs, original data, and LOF scores
return(data_with_lof)
}
if(method=="mahalanobis"){
library(dplyr)
library(Routliers)
#create error messaging here for non-numeric variables
xname <- as.character(substitute(x))
yname <- as.character(substitute(y))
if(class(data[[xname]])!="numeric" | class(data[[yname]])!="numeric"){
stop("Data must be numeric")
}
#select just the rows given by the user
subset <- select(data, {{x}}, {{y}})
#make this into a matrix
mat <- as.matrix(subset)
#run matrix on function and store results
results <- outliers_mahalanobis(x=mat)
print(results)
}
if (method == "kNN") {
if (!is.matrix(data)) {
data <- as.matrix(data)
}
# Calculate pairwise distances
dist_matrix <- as.matrix(dist(data))
# Get k-nearest neighbors for each point (excluding self-distance of 0)
knn_scores <- apply(dist_matrix, 1, function(row) {
sort(row, partial = k + 1)[2:(k + 1)]
})
# Calculate the average distance to the k-nearest neighbors
avg_knn_distances <- rowMeans(knn_scores)
# Determine the outliers based on the threshold
cutoff <- quantile(avg_knn_distances, threshold)
outliers <- which(avg_knn_distances > cutoff)
# Return results
return(list(outliers = outliers, scores = avg_knn_distances))
}
else {
stop("Method supplied must be kNN, mahalanobis, iForest, or LoF.")
}
}
?cli
o <- multiOutliers(mtcars, method = "kNN", threshold = 0.9, k = 5)
print(oi)
print(o)
o <- multiOutliers(mtcars, method = "kNN", threshold = 0.9, k = 5)
print(o)
print.multioutliers(o)
>>>>>>> upstream/main
univOutliers <- function(data, x = NULL, method = "boxplot") {
# Identify numeric columns in the dataset
numeric_columns <- sapply(data, is.numeric)
# If 'x' is not specified, use all numeric columns
if (is.null(x)) {
x <- names(data)[numeric_columns]
} else {
if (!x %in% names(data)) stop(paste("The specified column", x, "does not exist in the data frame."))
x <- list(x)
}
# Loop through each numeric variable specified in 'x'
for (column in x) {
# Boxplot Method
if (method == "boxplot") {
# Calculate boxplot stats using base R
stats <- boxplot.stats(data[[column]])
# Check if outliers exist
if (length(stats$out) == 0) {
cat("No univariate outliers detected for", column, "\n")
} else {
cat("Outliers detected for", column, ":\n")
# Print outliers with their corresponding row numbers
outlier_rows <- which(data[[column]] %in% stats$out)
for (i in outlier_rows) {
cat("Row", i, ":", data[[column]][i], "\n")
}
}
# Create the ggplot boxplot (optional, only for visualization)
library(ggplot2)
p <- ggplot(data, aes_string(y = column)) +
geom_boxplot(outlier.colour = "red", coef = 1.58) +
ggtitle(paste("Univariate Boxplot of", column)) +
theme_minimal()
print(p)
}
if(method=="mad"){
library(Routliers)
# Check if the input data is numeric
if (!is.numeric(data)) {
stop("Input data must be numeric.")
}
# Use the outliers_mad function to find outliers
res1 <- outliers_mad(data)
# Display the outliers
if (length(res1) == 0) {
cat("No outliers detected in the data.\n")
} else {
cat("Outliers detected:\n")
print(res1)
}
}
}
}
univOutliers(mtcars, "mpg", method="boxplot")
univOutliers(mtcars, "hp", method="boxplot")
univOutliers(mtcars, "mpg", method="boxplot")
#'@title Printing Univariate Outlier Detection
#'@description Prints identified univariate outliers using boxplot, Grubbs test, or MAD method
#'@export
#'@param x the results from a univariate outlier detection function (e.g., `boxplot`, `grubbsTest`, or MAD)
#'@returns A formatted print of the results of the univariate outlier detection
#'@import ggplot2
#'@import dplyr
#'@import cli
#'@examples
#'outliers_boxplot <- boxplot(mtcars$mpg, plot = FALSE)
#'outliers_grubbs <- grubbsTest(mtcars$mpg)
#'outliers_mad <- mad(mtcars$mpg)
#'print.univariateOutliers(outliers_boxplot)
#'print.univariateOutliers(outliers_grubbs)
#'print.univariateOutliers(outliers_mad)
#'
print.univariateOutliers <- function(x, ...) {
# Check that x is from an appropriate outlier detection method
if(!inherits(x, "boxplot") && !inherits(x, "grubbsTest") && !inherits(x, "mad")) {
stop("This function requires an object created by a univariate outlier detection method (e.g., boxplot, grubbsTest, or MAD).")
}
require(cli)
# Determine the method used and print accordingly
if (inherits(x, "boxplot")) {
method <- "Boxplot"
outliers <- x$out
} else if (inherits(x, "grubbsTest")) {
method <- "Grubbs Test"
outliers <- x$statistic
} else if (inherits(x, "mad")) {
method <- "MAD (Median Absolute Deviation)"
outliers <- x$outliers
}
cli_h1(paste("Method Chosen:", method))
cli_h2("Outliers \n")
# Check if there are any outliers to display
if(length(outliers) > 0) {
print(outliers)
} else {
cli_alert_success("No outliers detected.")
}
}
