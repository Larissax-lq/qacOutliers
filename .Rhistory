<<<<<<< HEAD
cat("Skewness:", skewness, "\n")
cat("Kurtosis:", kurtosis, "\n")
# Create Q-Q plot
qq_plot <- ggplot(data.frame(sample = data), aes(sample = sample)) +
stat_qq() +
stat_qq_line() +
labs(title = "Q-Q Normal Plot",
x = "Theoretical Quantiles",
y = "Sample Quantiles") +
theme_minimal()
print(qq_plot)
# Print outlier information based on Grubbs' test
if (grubbs_result$p.value < 0.05) {
outlier_value <- grubbs_result$outlier
cat("Detected outlier(s):", outlier_value, "\n")
} else {
cat("No significant outliers detected.\n")
}
}
# Example usage:
data <- c(2, 3, 5, 6, 7, 8, 8, 9, 10, 15)
grubbs_with_qq(data)
# Example usage:
data <- c(2, 3, 5, 6, 7, 8, 8, 9, 10, 18)
grubbs_with_qq(data)
# Function to calculate skewness
calc_skewness <- function(data) {
n <- length(data)
mean_data <- mean(data)
sd_data <- sd(data)
skewness <- sum((data - mean_data)^3) / ((n - 1) * sd_data^3)
return(skewness)
}
# Function to calculate kurtosis
calc_kurtosis <- function(data) {
n <- length(data)
mean_data <- mean(data)
sd_data <- sd(data)
kurtosis <- sum((data - mean_data)^4) / ((n - 1) * sd_data^4) - 3
return(kurtosis)
}
grubbs_with_qq <- function(data) {
# Perform Grubbs' test
grubbs_result <- grubbs.test(data)
# Warning about normal distribution
cat("Warning: Q-Q plot is only appropriate when the data is normally distributed.\n")
# Calculate and print skewness and kurtosis
skewness <- calc_skewness(data)
kurtosis <- calc_kurtosis(data)
cat("Skewness:", skewness, "\n")
cat("Kurtosis:", kurtosis, "\n")
# Create Q-Q plot
qq_plot <- ggplot(data.frame(sample = data), aes(sample = sample)) +
stat_qq() +
stat_qq_line() +
labs(title = "Q-Q Normal Plot",
x = "Theoretical Quantiles",
y = "Sample Quantiles") +
theme_minimal()
print(qq_plot)
# Print outlier information based on Grubbs' test
if (grubbs_result$p.value < 0.05) {
# Identify the outlier by finding the most extreme value
if (grubbs_result$alternative == "highest value") {
outlier_value <- max(data)
} else {
outlier_value <- min(data)
}
cat("Detected outlier(s):", outlier_value, "\n")
} else {
cat("No significant outliers detected.\n")
}
}
# Example usage:
data <- c(2, 3, 5, 6, 7, 8, 8, 9, 10, 18)
grubbs_with_qq(data)
# Example usage:
data <- c(2, 3, 5, 6, 7, 8, 8, 9, 10, 15)
grubbs_with_qq(data)
# Function to calculate skewness
calc_skewness <- function(data) {
n <- length(data)
mean_data <- mean(data)
sd_data <- sd(data)
skewness <- sum((data - mean_data)^3) / ((n - 1) * sd_data^3)
return(skewness)
}
# Function to calculate kurtosis
calc_kurtosis <- function(data) {
n <- length(data)
mean_data <- mean(data)
sd_data <- sd(data)
kurtosis <- sum((data - mean_data)^4) / ((n - 1) * sd_data^4) - 3
return(kurtosis)
}
grubbs_with_qq <- function(data) {
# Warning about normal distribution
cat("Warning: Q-Q plot is only appropriate when the data is normally distributed.\n")
# Calculate and print skewness and kurtosis
skewness <- calc_skewness(data)
kurtosis <- calc_kurtosis(data)
cat("Skewness:", skewness, "\n")
cat("Kurtosis:", kurtosis, "\n")
# Create Q-Q plot
qq_plot <- ggplot(data.frame(sample = data), aes(sample = sample)) +
stat_qq() +
stat_qq_line() +
labs(title = "Q-Q Normal Plot",
x = "Theoretical Quantiles",
y = "Sample Quantiles") +
theme_minimal()
print(qq_plot)
# Iteratively apply Grubbs' test to detect outliers
detected_outliers <- c()
while (length(data) > 2) { # Need at least 3 points for Grubbs' test
grubbs_result <- grubbs.test(data)
if (grubbs_result$p.value < 0.05) {
# Identify and remove the outlier
if (grubbs_result$alternative == "highest value") {
outlier_value <- max(data)
} else {
outlier_value <- min(data)
}
detected_outliers <- c(detected_outliers, outlier_value)
data <- data[data != outlier_value]
} else {
break
}
}
# Print detected outliers
if (length(detected_outliers) > 0) {
cat("Detected outlier(s):", paste(detected_outliers, collapse = ", "), "\n")
} else {
cat("No significant outliers detected.\n")
}
}
# Example usage:
data <- c(2, 3, 5, 6, 7, 8, 8, 9, 10, 15)
grubbs_with_qq(data)
# Example usage:
# Load mtcars dataset
data <- mtcars$mpg
# Apply the grubbs_with_qq function on the mpg column
grubbs_with_qq(data)
# Example usage:
data <- mtcars$hp
grubbs_with_qq(data)
#' Grubbs' Test for Outlier Detection
#'
#' @param data A numeric vector of data points.
#' @param alpha Significance level for the test (default is 0.05).
#' @return A list containing detected outliers, skewness, kurtosis, and QQ plot.
#' @importFrom outliers grubbs.test
#' @export
grubbs_test <- function(data, alpha = 0.05) {
# Check if data is normally distributed
if (shapiro.test(data)$p.value < 0.05) {
warning("Data is not normally distributed. Grubbs' test may not be appropriate.")
}
# Function to calculate skewness and kurtosis
calculate_skewness <- function(x) {
n <- length(x)
mean_x <- mean(x)
sd_x <- sd(x)
skewness <- sum((x - mean_x)^3) / (n * sd_x^3)
return(skewness)
}
calculate_kurtosis <- function(x) {
n <- length(x)
mean_x <- mean(x)
sd_x <- sd(x)
kurtosis <- sum((x - mean_x)^4) / (n * sd_x^4) - 3
return(kurtosis)
}
skewness <- calculate_skewness(data)
kurtosis <- calculate_kurtosis(data)
outliers <- NULL
iteration <- 1
repeat {
grubbs_result <- outliers::grubbs.test(data)
if (grubbs_result$p.value < alpha) {
outlier <- grubbs_result$outliers
outliers <- c(outliers, outlier)
data <- data[data != outlier]
iteration <- iteration + 1
} else {
break
}
}
# Create Q-Q plot
qqnorm(data)
qqline(data)
title("Q-Q Plot")
return(list(outliers = unique(outliers), skewness = skewness, kurtosis = kurtosis))
}
# Load necessary libraries
library(outliers)
# Sample data with outliers
data_1 <- c(10, 12, 12, 11, 13, 12, 100)
# Perform Grubbs' test
result_1 <- grubbs_test(data_1)
# Print the results
print(result_1)
# Perform Grubbs' test
result_1 <- grubbs_test(data_1)
# Print the results
print(result_1)
# Sample data without outliers
data_2 <- c(5, 6, 7, 5, 6, 7, 8)
# Perform Grubbs' test
result_2 <- grubbs_test(data_2)
# Print the results
print(result_2)
# Sample data that is not normally distributed
data_3 <- c(1, 1, 2, 2, 3, 10)
# Perform Grubbs' test
result_3 <- grubbs_test(data_3)
# Print the results
print(result_3)
#' Grubbs' Test for Outlier Detection
#'
#' @param data A numeric vector of data points.
#' @param alpha Significance level for the test (default is 0.05).
#' @return A list containing detected outliers, skewness, kurtosis, and QQ plot.
#' @importFrom outliers grubbs.test
#' @export
grubbs_test <- function(data, alpha = 0.05) {
# Check if data is numeric
if (!is.numeric(data)) {
stop("Input data must be a numeric vector.")
}
# Check if there are enough data points
if (length(data) < 3) {
stop("Data must contain at least three points for Grubbs' test.")
}
# Check for normality
normality_test <- shapiro.test(data)
if (normality_test$p.value < 0.05) {
warning("Data is not normally distributed. Grubbs' test may not be appropriate.")
return(NULL)  # Exit if data is not normally distributed
}
# Function to calculate skewness and kurtosis
calculate_skewness <- function(x) {
n <- length(x)
mean_x <- mean(x)
sd_x <- sd(x)
skewness <- sum((x - mean_x)^3) / (n * sd_x^3)
return(skewness)
}
calculate_kurtosis <- function(x) {
n <- length(x)
mean_x <- mean(x)
sd_x <- sd(x)
kurtosis <- sum((x - mean_x)^4) / (n * sd_x^4) - 3
return(kurtosis)
}
skewness <- calculate_skewness(data)
kurtosis <- calculate_kurtosis(data)
outliers <- c()
repeat {
grubbs_result <- outliers::grubbs.test(data)
if (grubbs_result$p.value < alpha) {
outlier <- grubbs_result$outliers
outliers <- c(outliers, outlier)
data <- data[data != outlier]
# Check if there are enough data points left
if (length(data) < 3) {
break  # Exit if not enough data points remain
}
} else {
break
}
}
# Create Q-Q plot
qqnorm(data)
qqline(data)
title("Q-Q Plot")
return(list(outliers = unique(outliers), skewness = skewness, kurtosis = kurtosis))
}
data_1 <- c(10, 12, 12, 11, 13, 12, 100)
result_1 <- grubbs_test(data_1)
print(result_1)
data_2 <- c(5, 6, 7, 5, 6, 7, 8)
result_2 <- grubbs_test(data_2)
print(result_2)
data_3 <- c(1, 1, 2, 2, 3, 10)
result_3 <- grubbs_test(data_3)
print(result_3)
# Set a seed for reproducibility
set.seed(123)
# Generate normally distributed data
data_1 <- rnorm(100, mean = 50, sd = 5)  # 100 data points with mean 50 and sd 5
# Introduce a single outlier
data_1 <- c(data_1, 75)  # Adding an outlier
# Perform Grubbs' test
result_1 <- grubbs_test(data_1)
# Print the results
print(result_1)
#' Grubbs' Test for Outlier Detection
#'
#' @param data A numeric vector of data points.
#' @param alpha Significance level for the test (default is 0.05).
#' @return A list containing detected outliers, skewness, kurtosis, and QQ plot.
#' @importFrom outliers grubbs.test
#' @export
grubbs_test <- function(data, alpha = 0.05) {
# Check if data is numeric
if (!is.numeric(data)) {
stop("Input data must be a numeric vector.")
}
# Check if there are enough data points
if (length(data) < 3) {
stop("Data must contain at least three points for Grubbs' test.")
}
# Check for normality
normality_test <- shapiro.test(data)
if (normality_test$p.value < 0.05) {
warning("Data is not normally distributed. Grubbs' test may not be appropriate.")
return(NULL)  # Exit if data is not normally distributed
}
# Function to calculate skewness and kurtosis
calculate_skewness <- function(x) {
n <- length(x)
mean_x <- mean(x)
sd_x <- sd(x)
skewness <- sum((x - mean_x)^3) / (n * sd_x^3)
return(skewness)
}
calculate_kurtosis <- function(x) {
n <- length(x)
mean_x <- mean(x)
sd_x <- sd(x)
kurtosis <- sum((x - mean_x)^4) / (n * sd_x^4) - 3
return(kurtosis)
}
skewness <- calculate_skewness(data)
kurtosis <- calculate_kurtosis(data)
outliers <- c()
current_data <- data  # Use a copy of the original data
repeat {
grubbs_result <- outliers::grubbs.test(current_data)
if (grubbs_result$p.value < alpha) {
outlier <- grubbs_result$outliers
outliers <- c(outliers, outlier)
# Remove detected outlier(s)
current_data <- current_data[current_data != outlier]
# Check if there are enough data points left
if (length(current_data) < 3) {
break  # Exit if not enough data points remain
}
} else {
break
}
}
# Create Q-Q plot
qqnorm(data)
qqline(data)
title("Q-Q Plot")
if (length(outliers) == 0) {
message("No outliers detected.")
}
return(list(outliers = unique(outliers), skewness = skewness, kurtosis = kurtosis))
}
set.seed(42)  # For reproducibility
data1 <- rnorm(100, mean = 50, sd = 5)  # 100 data points from a normal distribution
grubbs_test(data1)
set.seed(42)  # For reproducibility
data2 <- c(rnorm(99, mean = 50, sd = 5), 70)  # 99 normal points + 1 outlier
grubbs_test(data2)
set.seed(42)  # For reproducibility
data3 <- c(rnorm(95, mean = 50, sd = 5), 80, 85, 90)  # 95 normal points + 3 outliers
grubbs_test(data3)
#' Grubbs' Test for Outlier Detection
#'
#' @param data A numeric vector of data points.
#' @param alpha Significance level for the test (default is 0.05).
#' @return A list containing detected outliers, skewness, kurtosis, and QQ plot.
#' @importFrom outliers grubbs.test
#' @export
grubbs_test <- function(data, alpha = 0.05) {
# Check if data is numeric
if (!is.numeric(data)) {
stop("Input data must be a numeric vector.")
}
# Check if there are enough data points
if (length(data) < 3) {
stop("Data must contain at least three points for Grubbs' test.")
}
# Check for normality using the Shapiro-Wilk test
normality_test <- shapiro.test(data)
if (normality_test$p.value < 0.05) {
warning("Data is not normally distributed. Grubbs' test may not be appropriate.")
}
# Function to calculate skewness
calculate_skewness <- function(x) {
return(sum((x - mean(x))^3) / ((length(x) - 1) * sd(x)^3))
}
# Function to calculate kurtosis
calculate_kurtosis <- function(x) {
return(sum((x - mean(x))^4) / ((length(x) - 1) * sd(x)^4) - 3)
}
skewness <- calculate_skewness(data)
kurtosis <- calculate_kurtosis(data)
outliers <- c()
current_data <- data
repeat {
grubbs_result <- outliers::grubbs.test(current_data)
if (grubbs_result$p.value < alpha) {
outlier <- grubbs_result$outliers
outliers <- c(outliers, outlier)
current_data <- current_data[current_data != outlier]  # Remove detected outlier
} else {
break
}
# Exit if there are not enough data points left
if (length(current_data) < 3) {
break
}
}
# Create Q-Q plot
qqnorm(data)
qqline(data)
title("Q-Q Plot")
if (length(outliers) == 0) {
message("No outliers detected.")
}
return(list(outliers = unique(outliers), skewness = skewness, kurtosis = kurtosis))
}
set.seed(42)  # For reproducibility
data1 <- rnorm(100, mean = 50, sd = 5)  # 100 data points from a normal distribution
grubbs_test(data1)
set.seed(42)  # For reproducibility
data2 <- c(rnorm(99, mean = 50, sd = 5), 70)  # 99 normal points + 1 outlier
grubbs_test(data2)
set.seed(42)  # For reproducibility
data3 <- c(rnorm(95, mean = 50, sd = 5), 80, 85, 90)  # 95 normal points + 3 outliers
grubbs_test(data3)
#' Grubbs' Test for Outlier Detection
#'
#' @param data A numeric vector of data points.
#' @param alpha Significance level for the test (default is 0.05).
#' @return A list containing detected outliers, skewness, kurtosis, and QQ plot.
#' @importFrom outliers grubbs.test
#' @export
grubbs_test <- function(data, alpha = 0.05) {
# Check if data is numeric
if (!is.numeric(data)) {
stop("Input data must be a numeric vector.")
}
# Check if there are enough data points
if (length(data) < 3) {
stop("Data must contain at least three points for Grubbs' test.")
}
# Check for normality using the Shapiro-Wilk test
normality_test <- shapiro.test(data)
if (normality_test$p.value < 0.05) {
warning("Data is not normally distributed. Grubbs' test may not be appropriate.")
}
# Function to calculate skewness
calculate_skewness <- function(x) {
n <- length(x)
mean_x <- mean(x)
sd_x <- sd(x)
return(sum((x - mean_x)^3) / (n * sd_x^3))
}
# Function to calculate kurtosis
calculate_kurtosis <- function(x) {
n <- length(x)
mean_x <- mean(x)
sd_x <- sd(x)
return(sum((x - mean_x)^4) / (n * sd_x^4) - 3)
}
skewness <- calculate_skewness(data)
kurtosis <- calculate_kurtosis(data)
outliers <- c()
current_data <- data
repeat {
# Calculate Grubbs' test statistic
mean_data <- mean(current_data)
sd_data <- sd(current_data)
G <- max(abs(current_data - mean_data)) / sd_data
n <- length(current_data)
# Critical value from the t-distribution
critical_value <- (n - 1) / sqrt(n) * sqrt((qt(1 - alpha/(2*n), n - 2)^2) / (n - 2 + qt(1 - alpha/(2*n), n - 2)^2))
# Compare G to the critical value
if (G > critical_value) {
outlier <- current_data[which.max(abs(current_data - mean_data))]
outliers <- c(outliers, outlier)
current_data <- current_data[current_data != outlier]  # Remove detected outlier
} else {
break
}
# Exit if there are not enough data points left
if (length(current_data) < 3) {
break
}
}
# Create Q-Q plot
qqnorm(data)
qqline(data)
title("Q-Q Plot")
if (length(outliers) == 0) {
message("No outliers detected.")
}
return(list(outliers = unique(outliers), skewness = skewness, kurtosis = kurtosis))
}
set.seed(42)  # For reproducibility
data1 <- rnorm(100, mean = 50, sd = 5)  # 100 data points from a normal distribution
grubbs_test(data1)
set.seed(42)  # For reproducibility
data2 <- c(rnorm(99, mean = 50, sd = 5), 70)  # 99 normal points + 1 outlier
grubbs_test(data2)
=======
res1 <- outliers_mad(data[[column]])
# Display the outliers
if (length(res1) == 0) {
cat("No outliers detected for", column, "\n")
} else {
cat("Outliers detected for", column, ":\n")
print(res1)
}
}
}
}
univOutliers(mtcars, "mpg", method="boxplot")
univOutliers(mtcars, "hp", method="boxplot")
univOutliers <- function(data, x = NULL, method = "boxplot") {
# Ensure the method is either "boxplot" or "mad"
if (!(method %in% c("boxplot", "mad"))) {
stop("Method must be either 'boxplot' or 'mad'.")
}
# Identify numeric columns in the dataset
numeric_columns <- sapply(data, is.numeric)
# If 'x' is not specified, use all numeric columns
if (is.null(x)) {
x <- names(data)[numeric_columns]
} else {
if (!x %in% names(data)) stop(paste("The specified column", x, "does not exist in the data frame."))
x <- list(x)  # Convert to a list for uniform processing
}
# Loop through each numeric variable specified in 'x'
for (column in x) {
# Boxplot Method
if (method == "boxplot") {
# Calculate boxplot stats using base R
stats <- boxplot.stats(data[[column]])
# Check if outliers exist
if (length(stats$out) == 0) {
cat("No univariate outliers detected for", column, "\n")
} else {
cat("Outliers detected for", column, ":\n")
# Print outliers with their corresponding row numbers
outlier_rows <- which(data[[column]] %in% stats$out)
for (i in outlier_rows) {
cat("Row", i, ":", data[[column]][i], "\n")
}
}
# Create the ggplot boxplot (optional, only for visualization)
library(ggplot2)
p <- ggplot(data, aes_string(y = column)) +
geom_boxplot(outlier.colour = "red", coef = 1.58) +
ggtitle(paste("Univariate Boxplot of", column)) +
theme_minimal()
print(p)
}
if(method=="mad"){
library(Routliers)
# Check if the input data is numeric
if (!is.numeric(data)) {
stop("Input data must be numeric.")
}
# Use the outliers_mad function to find outliers
res1 <- outliers_mad(data)
# Display the outliers
if (length(res1) == 0) {
cat("No outliers detected in the data.\n")
} else {
cat("Outliers detected:\n")
print(res1)
}
}
}
univOutliers <- function(data, x = NULL, method = "boxplot") {
# Ensure the method is either "boxplot" or "mad"
if (!(method %in% c("boxplot", "mad"))) {
stop("Method must be either 'boxplot' or 'mad'.")
}
# Identify numeric columns in the dataset
numeric_columns <- sapply(data, is.numeric)
# If 'x' is not specified, use all numeric columns
if (is.null(x)) {
x <- names(data)[numeric_columns]
} else {
if (!x %in% names(data)) stop(paste("The specified column", x, "does not exist in the data frame."))
x <- list(x)  # Convert to a list for uniform processing
}
# Loop through each numeric variable specified in 'x'
for (column in x) {
# Boxplot Method
if (method == "boxplot") {
# Calculate boxplot stats using base R
stats <- boxplot.stats(data[[column]])
# Check if outliers exist
if (length(stats$out) == 0) {
cat("No univariate outliers detected for", column, "\n")
} else {
cat("Outliers detected for", column, ":\n")
# Print outliers with their corresponding row numbers
outlier_rows <- which(data[[column]] %in% stats$out)
for (i in outlier_rows) {
cat("Row", i, ":", data[[column]][i], "\n")
}
}
# Create the ggplot boxplot (optional, only for visualization)
library(ggplot2)
p <- ggplot(data, aes_string(y = column)) +
geom_boxplot(outlier.colour = "red", coef = 1.58) +
ggtitle(paste("Univariate Boxplot of", column)) +
theme_minimal()
print(p)
}
if(method=="mad"){
library(Routliers)
# Check if the input data is numeric
if (!is.numeric(data)) {
stop("Input data must be numeric.")
}
# Use the outliers_mad function to find outliers
res1 <- outliers_mad(data)
# Display the outliers
if (length(res1) == 0) {
cat("No outliers detected in the data.\n")
} else {
cat("Outliers detected:\n")
print(res1)
}
}
}}
univOutliers(mtcars, "hp", method="boxplot")
univOutliers(mtcars, "mpg", method="boxplot")
univOutliers <- function(data, x = NULL, method = "boxplot") {
# Identify numeric columns in the dataset
numeric_columns <- sapply(data, is.numeric)
# If 'x' is not specified, use all numeric columns
if (is.null(x)) {
x <- names(data)[numeric_columns]
} else {
if (!x %in% names(data)) stop(paste("The specified column", x, "does not exist in the data frame."))
x <- list(x)  # Convert to a list for uniform processing
}
# Loop through each numeric variable specified in 'x'
for (column in x) {
# Boxplot Method
if (method == "boxplot") {
# Calculate boxplot stats using base R
stats <- boxplot.stats(data[[column]])
# Check if outliers exist
if (length(stats$out) == 0) {
cat("No univariate outliers detected for", column, "\n")
} else {
cat("Outliers detected for", column, ":\n")
# Print outliers with their corresponding row numbers
outlier_rows <- which(data[[column]] %in% stats$out)
for (i in outlier_rows) {
cat("Row", i, ":", data[[column]][i], "\n")
}
}
# Create the ggplot boxplot (optional, only for visualization)
library(ggplot2)
p <- ggplot(data, aes_string(y = column)) +
geom_boxplot(outlier.colour = "red", coef = 1.58) +
ggtitle(paste("Univariate Boxplot of", column)) +
theme_minimal()
print(p)
}
if(method=="mad"){
library(Routliers)
# Check if the input data is numeric
if (!is.numeric(data)) {
stop("Input data must be numeric.")
}
# Use the outliers_mad function to find outliers
res1 <- outliers_mad(data)
# Display the outliers
if (length(res1) == 0) {
cat("No outliers detected in the data.\n")
} else {
cat("Outliers detected:\n")
print(res1)
}
}
}}
univOutliers(mtcars, "mpg", method="boxplot")
univOutliers(mtcars, "hp", method="boxplot")
univOutliers(mtcars, method="boxplot")
=======
setwd("/Users/braedenfalzarano/Documents/class/qac356_advanced_R/ClassProject")
usethis::create_package("qacTeam")
# Return results
return(list(outliers = outliers, scores = avg_knn_distances))
# Return results
return(list(outliers = outliers, scores = avg_knn_distances))
if (length(avg_knn_distances) == 0) {
stop("Error: avg_knn_distances is empty.")
}
else{
if (method == "kNN") {
if (!is.matrix(data)) {
data <- as.matrix(data)
}
threshold <- 0.95
k <- 5
# Calculate pairwise distances
dist_matrix <- as.matrix(dist(data))
# Get k-nearest neighbors for each point (excluding self-distance of 0)
knn_scores <- apply(dist_matrix, 1, function(row) {
sort(row, partial = k + 1)[2:(k + 1)]
})
# Calculate the average distance to the k-nearest neighbors
avg_knn_distances <- rowMeans(knn_scores)
if (length(avg_knn_distances) == 0) {
stop("Error: avg_knn_distances is empty.")
}
# Determine the outliers based on the threshold
cutoff <- quantile(avg_knn_distances, threshold)
outliers <- which(avg_knn_distances > cutoff)
# Return results
return(list(outliers = outliers, scores = avg_knn_distances))
}
else {
multiOutliers <- function(data, x, y, method="mahalanobis", ...){
#add other methods as people finish them here
if(method=="LoF"){
# Check if data is a matrix or data frame and convert if necessary
if (!is.matrix(data) && !is.data.frame(data)) {
stop("Data should be a matrix or data frame.")
}
# Rmove any non numeric data
data <- data[sapply(data, is.numeric)]
# Check if there are enough points for the LOF calculation
if (nrow(data) <= minPts) {
stop("Number of data points must be greater than minPts.")
}
# Calculate the LoF scores
lof_scores <- dbscan::lof(data, minPts = minPts)
# Append the LOF scores as a new column in the data frame
data_with_lof <- data.frame(ID = 1:nrow(data), data, LOF_Score = lof_scores)
# Return the data frame with IDs, original data, and LOF scores
return(data_with_lof)
}
if(method=="mahalanobis"){
#create error messaging here for non-numeric variables
#select just the rows given by the user
subset <- select(data, {{x}}, {{y}})
#make this into a matrix
mat <- as.matrix(subset)
#run matrix on function and store results
results <- outliers_mahalanobis(x=mat)
print(results)
}
if (method == "kNN") {
if (!is.matrix(data)) {
data <- as.matrix(data)
}
threshold <- 0.95
k <- 5
# Calculate pairwise distances
dist_matrix <- as.matrix(dist(data))
# Get k-nearest neighbors for each point (excluding self-distance of 0)
knn_scores <- apply(dist_matrix, 1, function(row) {
sort(row, partial = k + 1)[2:(k + 1)]
})
# Calculate the average distance to the k-nearest neighbors
avg_knn_distances <- rowMeans(knn_scores)
if (length(avg_knn_distances) == 0) {
stop("Error: avg_knn_distances is empty.")
}
# Determine the outliers based on the threshold
cutoff <- quantile(avg_knn_distances, threshold)
outliers <- which(avg_knn_distances > cutoff)
# Return results
return(list(outliers = outliers, scores = avg_knn_distances))
}
else {
stop("Method supplied must be kNN, mahalanobis, iForest, or LoF.")
}
}
multiOutliers <- function(data, x, y, method="mahalanobis", ...){
#add other methods as people finish them here
if(method=="LoF"){
# Check if data is a matrix or data frame and convert if necessary
if (!is.matrix(data) && !is.data.frame(data)) {
stop("Data should be a matrix or data frame.")
}
# Rmove any non numeric data
data <- data[sapply(data, is.numeric)]
# Check if there are enough points for the LOF calculation
if (nrow(data) <= minPts) {
stop("Number of data points must be greater than minPts.")
}
# Calculate the LoF scores
lof_scores <- dbscan::lof(data, minPts = minPts)
# Append the LOF scores as a new column in the data frame
data_with_lof <- data.frame(ID = 1:nrow(data), data, LOF_Score = lof_scores)
# Return the data frame with IDs, original data, and LOF scores
return(data_with_lof)
}
if(method=="mahalanobis"){
#create error messaging here for non-numeric variables
#select just the rows given by the user
subset <- select(data, {{x}}, {{y}})
#make this into a matrix
mat <- as.matrix(subset)
#run matrix on function and store results
results <- outliers_mahalanobis(x=mat)
print(results)
}
if (method == "kNN") {
if (!is.matrix(data)) {
data <- as.matrix(data)
}
threshold <- 0.95
k <- 5
# Calculate pairwise distances
dist_matrix <- as.matrix(dist(data))
# Get k-nearest neighbors for each point (excluding self-distance of 0)
knn_scores <- apply(dist_matrix, 1, function(row) {
sort(row, partial = k + 1)[2:(k + 1)]
})
# Calculate the average distance to the k-nearest neighbors
avg_knn_distances <- rowMeans(knn_scores)
if (length(avg_knn_distances) == 0) {
stop("Error: avg_knn_distances is empty.")
}
# Determine the outliers based on the threshold
cutoff <- quantile(avg_knn_distances, threshold)
outliers <- which(avg_knn_distances > cutoff)
# Return results
return(list(outliers = outliers, scores = avg_knn_distances))
}
else {
stop("Method supplied must be kNN, mahalanobis, iForest, or LoF.")
}
}
multiOutliers <- function(data, x, y, method="mahalanobis", ...){
#add other methods as people finish them here
if(method=="LoF"){
# Check if data is a matrix or data frame and convert if necessary
if (!is.matrix(data) && !is.data.frame(data)) {
stop("Data should be a matrix or data frame.")
}
# Rmove any non numeric data
data <- data[sapply(data, is.numeric)]
# Check if there are enough points for the LOF calculation
if (nrow(data) <= minPts) {
stop("Number of data points must be greater than minPts.")
}
# Calculate the LoF scores
lof_scores <- dbscan::lof(data, minPts = minPts)
# Append the LOF scores as a new column in the data frame
data_with_lof <- data.frame(ID = 1:nrow(data), data, LOF_Score = lof_scores)
# Return the data frame with IDs, original data, and LOF scores
return(data_with_lof)
}
if(method=="mahalanobis"){
#create error messaging here for non-numeric variables
#select just the rows given by the user
subset <- select(data, {{x}}, {{y}})
#make this into a matrix
mat <- as.matrix(subset)
#run matrix on function and store results
results <- outliers_mahalanobis(x=mat)
print(results)
}
if (method == "kNN") {
if (!is.matrix(data)) {
data <- as.matrix(data)
}
threshold <- 0.95
k <- 5
# Calculate pairwise distances
dist_matrix <- as.matrix(dist(data))
# Get k-nearest neighbors for each point (excluding self-distance of 0)
knn_scores <- apply(dist_matrix, 1, function(row) {
sort(row, partial = k + 1)[2:(k + 1)]
})
# Calculate the average distance to the k-nearest neighbors
avg_knn_distances <- rowMeans(knn_scores)
# Determine the outliers based on the threshold
cutoff <- quantile(avg_knn_distances, threshold)
outliers <- which(avg_knn_distances > cutoff)
# Return results
return(list(outliers = outliers, scores = avg_knn_distances))
}
else {
stop("Method supplied must be kNN, mahalanobis, iForest, or LoF.")
}
}
multiOutliers(mtcars, method = "kNN")
multiOutliers(mtcars, method = "mahalanobis")
multiOutliers(mtcars, method = "mahalanobis")
multiOutliers(mtcars, method = "kNN")
multiOutliers <- function(data, x, y, method="mahalanobis", k = 0.5, threshold = 0.95,...){
#add other methods as people finish them here
if(method=="LoF"){
# Check if data is a matrix or data frame and convert if necessary
if (!is.matrix(data) && !is.data.frame(data)) {
stop("Data should be a matrix or data frame.")
}
# Rmove any non numeric data
data <- data[sapply(data, is.numeric)]
# Check if there are enough points for the LOF calculation
if (nrow(data) <= minPts) {
stop("Number of data points must be greater than minPts.")
}
# Calculate the LoF scores
lof_scores <- dbscan::lof(data, minPts = minPts)
# Append the LOF scores as a new column in the data frame
data_with_lof <- data.frame(ID = 1:nrow(data), data, LOF_Score = lof_scores)
# Return the data frame with IDs, original data, and LOF scores
return(data_with_lof)
}
if(method=="mahalanobis"){
library(dplyr)
library(Routliers)
#create error messaging here for non-numeric variables
xname <- as.character(substitute(x))
yname <- as.character(substitute(y))
if(class(data[[xname]])!="numeric" | class(data[[yname]])!="numeric"){
stop("Data must be numeric")
}
#select just the rows given by the user
subset <- select(data, {{x}}, {{y}})
#make this into a matrix
mat <- as.matrix(subset)
#run matrix on function and store results
results <- outliers_mahalanobis(x=mat)
print(results)
}
if (method == "kNN") {
if (!is.matrix(data)) {
data <- as.matrix(data)
}
# Calculate pairwise distances
dist_matrix <- as.matrix(dist(data))
# Get k-nearest neighbors for each point (excluding self-distance of 0)
knn_scores <- apply(dist_matrix, 1, function(row) {
sort(row, partial = k + 1)[2:(k + 1)]
})
# Calculate the average distance to the k-nearest neighbors
avg_knn_distances <- rowMeans(knn_scores)
# Determine the outliers based on the threshold
cutoff <- quantile(avg_knn_distances, threshold)
outliers <- which(avg_knn_distances > cutoff)
# Return results
return(list(outliers = outliers, scores = avg_knn_distances))
}
else {
stop("Method supplied must be kNN, mahalanobis, iForest, or LoF.")
}
}
?cli
o <- multiOutliers(mtcars, method = "kNN", threshold = 0.9, k = 5)
print(oi)
print(o)
o <- multiOutliers(mtcars, method = "kNN", threshold = 0.9, k = 5)
print(o)
print.multioutliers(o)
>>>>>>> upstream/main
univOutliers <- function(data, x = NULL, method = "boxplot") {
# Identify numeric columns in the dataset
numeric_columns <- sapply(data, is.numeric)
# If 'x' is not specified, use all numeric columns
if (is.null(x)) {
x <- names(data)[numeric_columns]
} else {
if (!x %in% names(data)) stop(paste("The specified column", x, "does not exist in the data frame."))
x <- list(x)
}
# Loop through each numeric variable specified in 'x'
for (column in x) {
# Boxplot Method
if (method == "boxplot") {
# Calculate boxplot stats using base R
stats <- boxplot.stats(data[[column]])
# Check if outliers exist
if (length(stats$out) == 0) {
cat("No univariate outliers detected for", column, "\n")
} else {
cat("Outliers detected for", column, ":\n")
# Print outliers with their corresponding row numbers
outlier_rows <- which(data[[column]] %in% stats$out)
for (i in outlier_rows) {
cat("Row", i, ":", data[[column]][i], "\n")
}
}
# Create the ggplot boxplot (optional, only for visualization)
library(ggplot2)
p <- ggplot(data, aes_string(y = column)) +
geom_boxplot(outlier.colour = "red", coef = 1.58) +
ggtitle(paste("Univariate Boxplot of", column)) +
theme_minimal()
print(p)
}
if(method=="mad"){
library(Routliers)
# Check if the input data is numeric
if (!is.numeric(data)) {
stop("Input data must be numeric.")
}
# Use the outliers_mad function to find outliers
res1 <- outliers_mad(data)
# Display the outliers
if (length(res1) == 0) {
cat("No outliers detected in the data.\n")
} else {
cat("Outliers detected:\n")
print(res1)
}
}
}
}
univOutliers(mtcars, "mpg", method="boxplot")
univOutliers(mtcars, "hp", method="boxplot")
univOutliers(mtcars, "mpg", method="boxplot")
>>>>>>> upstream/main
